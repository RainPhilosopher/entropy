<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
    <script src="../../build/entropy.js"></script>
</head>
<body>
    
</body>
<script>
  /*Globalne zmienne, referencje do kontekstu canvasa i obiektu gry.*/
    var game;

    window.addEventListener("load", function (e) {
        game = new Entropy.Game("start");
    });

/*
    Stan startowy.

    Każdy stan jest definiowany za pomocą trzech funkcji: initialize, onEnter, onExit.
    Są też funkcje opisujące przejścia do innych stanów, np. co ma sie stać jak przechodzimy ze stanu "start"
    do stanu "level1". O tym napiszę kiedy indziej.

    Każda z funkcji (initialize, onEnter, onExit) przyjmuje dwa parametry. Pierwszy to główny obiekt gry. Przez niego możemy dostać się do różnych części systemu:
    - silnika
    - obsługi wejścia itp.

    Drugi parametr to funkcja wywoływana gdy gotowi jesteśmy zakończyć działanie. Np. w funkcji onEnter chcemy z pomocą jQuery płynie rozjaśnić ekran.
    Animacje jQuery są asynchroniczne, więc funkcja onEnter zakończy się wcześniej niż animacja. To nie jest porządane. Tu przydaje się drugi argument - done, który trzeba wywołać
    po wykonaniu się animacji. Bez wywołania tej funkcji przechodzenie do następnego stanu będzie wstrzymane i cała maszynka się zablokuje. 
 */
Entropy.Game.State({
    name: "start",
    initialize: function (game, done) {
        Entropy.Const("WIDTH", 800);
        Entropy.Const("HEIGHT", 600);

        var canvas = document.createElement("canvas");
        canvas.height = Entropy.HEIGHT;
        canvas.width = Entropy.WIDTH;
        this.ctx = canvas.getContext("2d");

        document.body.appendChild(canvas);

        done();
    },
    onEnter: function (game, done) {
        //Tworzymy 100 encji "Ball". Encja jest zdefiniowana niżej.
        for (var i = 0; i < 100; i++) {
            game.engine.create("Ball", /*x*/Entropy.WIDTH / 2, /*y*/Entropy.HEIGHT / 2, /*radius*/ 10, /*color*/"red");
        }
        
        //dodajemy system odpoiwadający za ruch
        game.engine.addSystem("Motion", 4);
        //system odpowiadający za renderowanie, parametrem jest referencja do kontekstu canvasa (wiem że jest globalna, ale w normalnym zastosowaniu nie powinna być)
        game.engine.addSystem("Render", 5, this.ctx);
        
        //start gry, od tego momentu rozpoczyna się pętla po systemach, domyślnie 60FPS
        game.start();
        
        done();
    },
    onExit: function (game, done) {

    }
});

/*
Zanim zdefinijemy encje, musimy zdefiniować komponenty z których będą się składać.

this wewnątrz funkcji initialize wskazuje na obiekt komponentu. Możemy do niego dodwać właściwości, które będą potem widoczne w komponentach encji.
Funkcja initialize jest wzorcem na podstawie którego wiemy jak tworzyć komponenty. Parametry do tej funkcji są przekaywane w momencie dodawanie komponentu de encji
w jej metodzie 'create'. Np. wywołanie 'this.add("Position", 2, 3)' w metodzie 'create' wzorca encji spowoduje wywołanie funkcji 'initialize' z komponentu "Position"
i przypisanie do obiektu komponentu dwóch właściwości - x = 2, y = 3.
 */

/*Komponenty*/
Entropy.Engine.Component({
    name: "Position",
    initialize: function (x, y) {
        this.x = x;
        this.y = y;
    }
});

Entropy.Engine.Component({
    name: "Velocity",
    initialize: function (vx, vy) {
        this.vx = vx;
        this.vy = vy;
    }
});

Entropy.Engine.Component({
    name: "Circle",
    initialize: function (radius, color) {
        this.radius = radius;
        this.color = color;
    }
});

/*Encje*/

Entropy.Engine.Entity({
    name: "Ball", //nazwa encji, wykorzystywana przy jej tworzeniu bądź wyszukiwaniu
    family: "Balls|Moveable", //Rodziny do których należy encja. Za pomocą rodzin można bardzo szybko wyszukiwać i pobierać encję. Zastosowwanie będzie omówione przy Systemach.
    /*Wywoływana podczas tworzenia encji za pomocą meteody 'create' z game.engine (to nie są te same funkcje, tylko tak samo się nazywają).
    Obie metody, 'create' i 'remove' przyjmują jako pierwszy parametr referencję do głównego obiektu gry. Następne parametry w metodzie 'create' to to co przekazujemy
    gdy tworzymy encje: 'game.engine.create("Ball", 2, 3, 5, "red");' To wywołanie doda do systemu encją Ball i wywoła jej metodę 'create' z parametrami x = 2, y = 3, radius = 5, color = "red".
    */
    create: function (game, x, y, radius, color) {
        this.add("Position", x, y)
            .add("Velocity", -100 + Math.round(Math.random() * 200), -100 + Math.round(Math.random() * 200))
            .add("Circle", radius, color);
    },
    /* Ta metoda wywoływana jest automatycznie kiedy usuwamy encję z systemu. Nie jest obowiązkowa, ale możę być przydatna.
    Np. jeśli w metodzie create dodaliśmy jakiegoś sprite'a do sceny jakiegoś zewnętrznego renderera (np. PIXI.js),
    to w metodzie 'remove' możemy go usunąć. Gdybyśmy go nie usunęli ręcznie, to mimo że encja już nie istnieje, to sprite dalej byłby wyświetlany.
    Ogólnie dobrze jest wykorzystywać to miejsce do czyszczenia ewentualnych pozostałości po encji, które nie są usuwane automatycznie.
    */
    remove: function (game) {}
});


/*Systemy*/

/*Okej, mamy komponenty, które trzymają dane. Mamy encje, które są zbiorem komponentów. Teraz potrzebujemy czegoś, co tchnie w to wszystko trochę życia.
W końcu nie budujemy bazy danych tylko grę.

Cała funkcjonalność znajduje się w systemach. Ogólna zasada działania systemu jest taka:
- przy każdej iteracji pętli gry wywoływana jest metod 'update'. Przyjumje dwa parametry - delta czasu i obiekt eventu. Drugi nas póki co nie interesuje.
- w metodzie update można zrobić wszystko, ale typowy scenariusz jest taki:
    1. pobierz encje, zwierające komponenty które interesują dany system
    2. w pęteli zrób coś z każdą encją (np. w systemie motion możemy pobrać wszystkie encje z komponentem 'Position' i 'Velocity' i przesunąć każdą z nich - zmienić wartości 'x' i 'y' w komponenie 'Position')
    3. zakończ działanie

Systemy definiowane są w podobny sposób jak encje i komponenty. Najważniejsze metody to 'initialize', która wywołyłwana jest tylko raz,
gdy dodajemy system. Jako parametry przyjmuje to co wpiszemy dodając system: game.engine.addSystem("Render", 4, mojCanvas);
Ta czwórka to nie jest prametr dla funkcji initialize, to priorytet.
Systemy są przechowywane jako posortowana lista, ponieważ może być ważna kolejność w jakiej wywoływane są systemy.
Np. możemy najpierw chciec coś wyrenderować, a dopiero potem obliczyć nową pozycję. Priorytety nam to umożliwiają. Im niższa liczba, tym wyższy priorytet systemu.
*/

Entropy.Engine.System({
    name: "Render", //nazwa systemu
    //priority: 2,       to pole jest opcjonalne, można podać priorytet przy dodwaniu systemu
    initialize: function (ctx) {
        /*Ustawiam kontekst canvasa, potem mam do niego łatwy dostęp w metodzie 'update'*/
        this.ctx = ctx;
    },
    update: function (delta, event) {
        /*Pobieram wszystkie encje, które zawierają komponent Circle i Position.
         W komponencie Circle znajdują się informacje o promieniu i kolrze encji. Te informacje, wraz z pozycją,
          wystarczą do wyrenderowania encji.
        */
        var entities = this.engine.getEntitiesWith(["Position", "Circle"]); //tablica z encjami

        this.ctx.clearRect(0, 0, Entropy.WIDTH, Entropy.HEIGHT);

        for (var i = 0, max = entities.length; i < max; i += 1) {
            var e = entities[i]; // obiekt encji

            /*Z obiektu encji mamy dostęp do wszystkich jej komponentów. Wyszukaliśmy encje z komponentami 'Position' i 'Circle', więc one na pewno tam będą.
            Spróbujmy je znaleźć.
            Obiekty komponentów znajdują się we właściowości 'components' encji. Każda encja ma taką właściowość. Nazwy komponentów zą pisane małymi literami,
            więc nawet jeśli dodwaliścy do encji komponent 'Position', dostęp do niego usyzkamy pisząc 'e.components.position'.
            */

            var circle = e.components.circle;
            var position = e.components.position;

            this.ctx.beginPath();
            this.ctx.moveTo(position.x, position.y);
            this.ctx.arc(position.x, position.y, circle.radius, 0, 2 * Math.PI, false);
            this.ctx.fillStyle = circle.color;
            this.ctx.fill();
        }

        /*To koniec naszego systemu renderowania*/
    }
});

Entropy.Engine.System({
    name: "Motion",
    initialize: function () {
    },
    update: function (delta, event) {
        /* W tym systemie wykorzystamy inną metodę do pobierania encji.
        Metoda 'getFamily' pobiera encje należące do danej rodziny. Zwraca je w formie listy połączonej.
        w naszym przypdaku zwrócone zostaną wszystkie encje 'Ball', ponieważ definując je przyporządkowaliśmy je do rodziny 'Moveable'.
        */
        var movingEntities = this.engine.getFamily("Moveable");

        var node = movingEntities.head;
        while (node) {
            /*Dostęp do obiektu encji odbywa się przez właściwość 'data' każdego węzła listy.*/
            var entity = node.data;

            /*dalej postępujemy tak samo jak w systemie renderowania, bierzemy komponent i coś z nim robimy*/
            var position = entity.components.position;
            var radius = entity.components.circle.radius;
            var velocity = entity.components.velocity;

            /*Odbicia od ścian*/
            if (position.x <= radius || position.x >= (Entropy.WIDTH - radius)) {
                velocity.vx = -velocity.vx;
            } else if (position.y <= radius || position.y >= (Entropy.HEIGHT - radius)) {
                velocity.vy = -velocity.vy;
            }
            //console.log(position)
            position.x += delta / 1000 * velocity.vx;
            position.y += delta / 1000 * velocity.vy;

            /*nasępny węzeł*/
            node = node.next;
        }
    }
});
</script>
</html>