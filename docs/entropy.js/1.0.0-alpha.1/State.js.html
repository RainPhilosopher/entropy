<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>State.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="-_.html"></a></li><li><a href="Component.html">Component</a></li><li><a href="ComponentStore.html">ComponentStore</a><ul class='methods'><li data-type='method'><a href="ComponentStore.html#register">register</a></li></ul></li><li><a href="Entity.html">Entity</a></li><li><a href="EntityStore.html">EntityStore</a></li><li><a href="Entropy.html">Entropy</a><ul class='methods'><li data-type='method'><a href="Entropy.html#defineState">defineState</a></li><li data-type='method'><a href="Entropy.html#emit">emit</a></li><li data-type='method'><a href="Entropy.html#off">off</a></li><li data-type='method'><a href="Entropy.html#on">on</a></li><li data-type='method'><a href="Entropy.html#once">once</a></li><li data-type='method'><a href="Entropy.html#pause">pause</a></li><li data-type='method'><a href="Entropy.html#registerComponent">registerComponent</a></li><li data-type='method'><a href="Entropy.html#resume">resume</a></li><li data-type='method'><a href="Entropy.html#start">start</a></li><li data-type='method'><a href="Entropy.html#startResponding">startResponding</a></li><li data-type='method'><a href="Entropy.html#stop">stop</a></li><li data-type='method'><a href="Entropy.html#stopResponding">stopResponding</a></li></ul></li><li><a href="EventEmitter.html">EventEmitter</a><ul class='methods'><li data-type='method'><a href="EventEmitter.html#emit">emit</a></li><li data-type='method'><a href="EventEmitter.html#off">off</a></li><li data-type='method'><a href="EventEmitter.html#on">on</a></li><li data-type='method'><a href="EventEmitter.html#once">once</a></li><li data-type='method'><a href="EventEmitter.html#startResponding">startResponding</a></li><li data-type='method'><a href="EventEmitter.html#stopResponding">stopResponding</a></li></ul></li><li><a href="Query.html">Query</a></li></ul><h3>Global</h3><ul><li><a href="global.html#_componentsIdsMap">_componentsIdsMap</a></li><li><a href="global.html#_entities">_entities</a></li><li><a href="global.html#_entitiesCount">_entitiesCount</a></li><li><a href="global.html#_entitiesIdsPool">_entitiesIdsPool</a></li><li><a href="global.html#_entitiesToAdd">_entitiesToAdd</a></li><li><a href="global.html#_entitiesToRemove">_entitiesToRemove</a></li><li><a href="global.html#_events">_events</a></li><li><a href="global.html#_factories">_factories</a></li><li><a href="global.html#_greatestComponentId">_greatestComponentId</a></li><li><a href="global.html#_isClearingScheduled">_isClearingScheduled</a></li><li><a href="global.html#_modifiedEntities">_modifiedEntities</a></li><li><a href="global.html#_pools">_pools</a></li><li><a href="global.html#_queries">_queries</a></li><li><a href="global.html#_systems">_systems</a></li><li><a href="global.html#_systemsToAdd">_systemsToAdd</a></li><li><a href="global.html#_systemsToRemove">_systemsToRemove</a></li><li><a href="global.html#_wasClearingPerformed">_wasClearingPerformed</a></li><li><a href="global.html#add">add</a></li><li><a href="global.html#addEntity">addEntity</a></li><li><a href="global.html#addSystem">addSystem</a></li><li><a href="global.html#change">change</a></li><li><a href="global.html#clear">clear</a></li><li><a href="global.html#current">current</a></li><li><a href="global.html#feed">feed</a></li><li><a href="global.html#getAllEntities">getAllEntities</a></li><li><a href="global.html#getEntities">getEntities</a></li><li><a href="global.html#getFPS">getFPS</a></li><li><a href="global.html#getMaxAllowedFPS">getMaxAllowedFPS</a></li><li><a href="global.html#getSimulationTimestep">getSimulationTimestep</a></li><li><a href="global.html#isIn">isIn</a></li><li><a href="global.html#isRunning">isRunning</a></li><li><a href="global.html#removeEntity">removeEntity</a></li><li><a href="global.html#removeSystem">removeSystem</a></li><li><a href="global.html#resetFrameDelta">resetFrameDelta</a></li><li><a href="global.html#setMaxAllowedFPS">setMaxAllowedFPS</a></li><li><a href="global.html#setSimulationTimestep">setSimulationTimestep</a></li><li><a href="global.html#start">start</a></li><li><a href="global.html#stop">stop</a></li><li><a href="global.html#ticker">ticker</a></li><li><a href="global.html#update">update</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">State.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import stampit from 'stampit';

import { isFunction, isString } from './helpers';

const State = stampit({
  deepProperties: {
    _states: {},
    _queue: [],
    _shifting: false,
    _currentState: {
      name: 'dummy',
      transitions: {},
      constArgs: [],
    }
  },
  init() {
    this._states = {};
    this._queue = [];
    this._shifting = false;
    this._currentState = {
      name: '__dummy',
      transitions: {},
      constArgs: [],
    };
  },
  methods: {
    /**
     * Registers new state. Registered states are shared between State instances.
     * State methods are asynchronous. Their last argument is always a callback function, that must be called
     * when the function finishes. This is handy when you want implement smooth transitions
     * between states using animations (for example, jQuery animations), that are very often asynchronous.
     *
     * @example
     *     let machinka = Taste();
     *
     *     mackinka.feed({
     *         name: "initialize",
     *         initialize: function (done) {
     *             console.log('State initialized.');
     *
     *             return done();
     *         },
     *         enter: function (done) {
     *             console.log('State entered.');
     *
     *             return done();
     *         },
     *         exit: function (done) {
     *             console.log('State exited.');
     *
     *             return done();
     *         },
     *         transitions: {
     *             menu: function (game, nextState, done) {
     *                 console.log('Transitioning from `initialize` to `menu`.');
     *
     *                 return done();
     *             }
     *         }
     *     });
     *
     *     mackinka.change('initialize');
     * @method feed
     * @chainable
     * @param {Object} state state object (see example)
     * @return {Taste} Taste instance
     */
    define(state) {
      this._states[state.name] = Object.assign({}, state, {
        _initialized: false,
        manager: this,
        transitions: state.transitions || {},
        constArgs: state.constArgs || [],
      });

      return this;
    },
    /**
     * Changes state to one identified by `name` parameter.
     * Changing state process looks roughly like this:
     *  1. calling current state's `exit` method (if present)
     *  2. calling next state's `initialize` method (if present and state wasn't initialized)
     *  3. calling transition function (if present)
     *  4. calling next state's `enter` method (if present)
     *
     * Transition functions are called when transitionig from one state to another. They are called after current state
     * `exit` method and before next state's `enter` method. If the next state is not initailizes, its `initialize` method is
     * called after `exit` and before transition method. Transition arguments are (in order):
     *  - next state object
     *  - [here come constant state arguments]
     *  - [here come arguments given after `stateName`]
     *  - done callback
     *
     * @method change
     * @chainable
     * @param {String}  stateName   state to change into
     * @param {Any}     ...args     addidtional parameters will be applied to transition method
     * @return {Taste}              Taste instance
     */
    change(stateName, ...args) {
      if (!isString(stateName) || !(stateName in this._states)) {
        return this;
      }

      const nextState = this._states[stateName];
      const doneCallback = () => this._shift();

      this._queue.push({
        fn: () => this._exitState(this._currentState, doneCallback),
      });

      if (!nextState._initialized) {
        this._queue.push({
          fn: () => this._initializeState(nextState, doneCallback),
        });

        this._queue.push({
          fn: () => this._setInitialized(nextState, doneCallback),
        });
      }

      this._queue.push({
        fn: () => this._doTransition(this._currentState, stateName, nextState, ...args, doneCallback),
      });

      this._queue.push({
        fn: () => this._enterState(nextState, doneCallback),
      });

      this._queue.push({
        fn: () => this._setCurrentState(nextState, doneCallback),
      });

      if (!this._shifting) {
        this._shift();
      }

      return this;
    },
    /**
     * Returns name of the current state.
     *
     * @method current
     * @return {String} name of the current state
     */
    current() {
      return this._currentState.name;
    },
    /**
     * Checks whether state machine is in state identified by name.
     *
     * @method isIn
     * @param  {String}  stateName state's name
     * @return {Boolean}
     */
    isIn(stateName) {
      return stateName === this._currentState.name;
    },
    _shift() {
      const queueHead = this._queue.shift();

      if (queueHead == null) {
        this._shifting = false;

        return;
      }

      this._shifting = true;

      return queueHead.fn();
    },
    _setCurrentState(state, done) {
      this._currentState = state;

      return done();
    },
    _setInitialized(state, done) {
      state._initialized = true;

      return done();
    },
    _initializeState(state, done) {
      if (isFunction(state.initialize)) {
        return state.initialize(...state.constArgs, done);
      }

      return done();
    },
    _enterState(state, done) {
      if (isFunction(state.enter)) {
        return state.enter(...state.constArgs, done);
      }

      return done();
    },
    _exitState(state, done) {
      if (isFunction(state.exit)) {
        return state.exit(...state.constArgs, done);
      }

      return done();
    },
    _doTransition(currentState, nextStateName, nextState, ...args) {
      if (nextStateName in currentState.transitions &amp;&amp; isFunction(currentState.transitions[nextStateName])) {
        return currentState.transitions[nextStateName](nextState, ...nextState.constArgs, ...args);
      }

      const done = args.pop();

      return done();
    },
  },
});

export default State;
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Fri Nov 25 2016 12:38:41 GMT+0100 (CET) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
