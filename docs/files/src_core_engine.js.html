<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src\core\engine.js - Entropy</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="..\..\entropy.png" title="Entropy"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.3.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Engine.html">Engine</a></li>
                                <li><a href="../classes/Entity.html">Entity</a></li>
                                <li><a href="../classes/Entropy.html">Entropy</a></li>
                                <li><a href="../classes/Game.html">Game</a></li>
                                <li><a href="../classes/Plugin.html">Plugin</a></li>
                                <li><a href="../classes/Plugin.Input.html">Plugin.Input</a></li>
                                <li><a href="../classes/Pool.html">Pool</a></li>
                                <li><a href="../classes/Query.html">Query</a></li>
                                <li><a href="../classes/State.html">State</a></li>
                                <li><a href="../classes/Ticker.html">Ticker</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/Entropy.html">Entropy</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src\core\engine.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x27;use strict&#x27;;

var extend = require(&#x27;node.extend&#x27;);
var config = require(&#x27;./config&#x27;);
var array = require(&#x27;./fastarray&#x27;);
var is = require(&#x27;check-types&#x27;);
var debug = require(&#x27;./debug&#x27;);
var register = require(&#x27;./register&#x27;);
var slice = Array.prototype.slice;

var Query = require(&#x27;./query&#x27;);
var EventEmitter = require(&#x27;./event&#x27;);
var Pool = require(&#x27;./pool&#x27;);
var Entity = require(&#x27;./entity&#x27;);

/**
 * Engine class. Class is used internaly. User should not instatiate this class.
 *
 * @class Engine
 * @extends EventEmitter
 * @constructor
 */
function Engine (game) {
    EventEmitter.call(this);

    /**
     * Instance of {{#crossLink &quot;Game&quot;}}Game{{/crossLink}} class.
     *
     * @property game
     * @type {Game}
     */
    this.game = game;

    /**
     * Indicates the greatest entity ID present in the system.
     * Used to generate new IDs.
     *
     * @property _greatestEntityID
     * @private
     * @type Number
     */
    this._greatestEntityID = 0;

    /**
     * Pool of currently not used entity IDs. Will be reused.
     *
     * @property _idsToReuse
     * @private
     * @type Pool
     */
    this._idsToReuse = new Pool(config(&#x27;ids_to_reuse_pool_size&#x27;));

    /**
     * Systems that are processed every tick.
     *
     * @property _systems
     * @private
     * @type Array
     */
    this._systems = [];

    /**
     * Array with entities. Array index corresponds to ID of an entity.
     *
     * @property _entities
     * @private
     * @type Array
     */
    this._entities = array.alloc(10000);

    this._modifiedEntities = array.alloc(10000);
    this._modifiedEntitiesLength = 0;

    this._entitiesToAdd = new Pool(1000);
    this._entitiesToRemove = new Pool(1000);
    this._systemsToAdd = new Pool(1000);
    this._systemsToRemove = new Pool(1000);

    this._entitiesPool = {};
    this._componentsPool = {};

    this._queries = [];

    this._entitiesCount = 0;

    this._performClearing = false;

    register.setCannotModify();

    //Initialize components and entities pools.
    register.listComponentsNames().forEach(function (name) {
        this._componentsPool[name] = new Pool(config(&#x27;initial_components_pool_size&#x27;));
    }, this);

    register.listEntitiesNames().forEach(function (name) {
        this._entitiesPool[name] = new Pool(config(&#x27;initial_entities_pool_size&#x27;));
    }, this);
}

/**
 * Registers new component pattern.
 * Only argument should be an object with obligatory &#x60;name&#x60; property and &#x60;initialize&#x60; method.
 * This method is used to assign some data to component object. &#x60;this&#x60; inside &#x60;initialize&#x60; function is a
 * reference to newly created component object.
 *
 * @example
 *     Entropy.Engine.Component({
 *         name: &quot;Position&quot;,
 *         initialize: function (x, y) {
 *             this.x = x;
 *             this.y = y;
 *         },
 *         //not obligatory
 *         reset: function () {
 *             this.x = 0;
 *             this.y = 0;
 *         }
 *     });
 *
 * @method Component
 * @static
 * @param {Object} component component pattern
 */
Engine.Component = function (component) {
    register.registerComponent(component);
};

/**
 * Registers new entity pattern.
 *
 * Pattern is an object with following properties:
 *  - __name__ (required) - name of an entity
 *  - __create__ (required) - method called when creating new entity. Here you should add initial components to an entity.
 *   &#x60;this&#x60; inside function references newly created entity object (instance of {{#crossLink &quot;Entity&quot;}}Entity{{/crossLink}} class).
 *   Function is called with first argument being &#x60;game&#x60; object and every others are parameters with witch {{#crossLink &quot;Engine/create:method&quot;}}create{{/crossLink}} method is called.
 *  - __remove__ (optional) - method called when entity is removed from the system. This is good place to clean after entity (ex. remove some resources from renderer).
 *   First and only argument is a &#x60;game&#x60; object.
 *
 * @example
 *     Entropy.Engine.Entity({
 *         name: &quot;Ball&quot;,
 *         create: function (game, x, y, radius) {
 *             var sprite = new Sprite(&quot;Ball&quot;);
 *
 *             game.container.make(&quot;renderer&quot;).addSprite(sprite);
 *
 *             this.add(&quot;Position&quot;, x, y)
 *                 .add(&quot;Radius&quot;, radius)
 *                 .add(&quot;Velocity&quot;, 5, 5)
 *                 .add(&quot;Sprite&quot;, sprite);
 *         },
 *         //not oblgatory
 *         remove: function (game) {
 *             game.container.make(&quot;renderer&quot;).removeSprite(this.components.sprite.sprite);
 *         }
 *     });
 *
 * @method Entity
 * @static
 * @param {Object} entity entity pattern
 */
Engine.Entity = function (entity) {
    register.registerEntity(entity);
};

/**
 * Registers new system pattern.
 *
 * @example
 *     Entropy.Engine.System({
 *         name: &quot;MovementSystem&quot;,
 *         priority: 1, //not obligatory
 *         initialize: function () {
 *             this.query = new Entropy.Engine.Query([&quot;Position&quot;, &quot;Velocity&quot;]);
 *         },
 *         update: function (delta) {
 *             var entities = this.engine.getEntities(this.query);
 *             var e;
 *
 *             var i = 0;
 *             while (e = entities[i]) {
 *                 var position = e.components.position;
 *                 var velocity = e.components.velocity;
 *
 *                 position.x += delta / 1000 * velocity.vx;
 *                 position.y += delta / 1000 * velocity.vy;
 *
 *                 i++;
 *             }
 *         },
 *         //not obligatory
 *         remove: function () {
 *
 *         }
 *     });
 *
 * @method System
 * @static
 * @param {Object} system system pattern object
 */
Engine.System = function (system) {
    register.registerSystem(system);
};

/**
 * Used to perform matching of entities.
 * Only parameter is an array of component names to include or object with &#x60;include&#x60; and/or &#x60;exclude&#x60; properties,
 * witch are arrays of component names to respectively include and/or exclude.
 *
 * @example
 *     var q1 = new Entropy.Engine.Query([&quot;Position&quot;, &quot;Velocity&quot;]);
 *     var q2 = new Entropy.Engine.Query({
 *         include: [&quot;Position&quot;, &quot;Velocity&quot;],
 *         exclude: [&quot;Sprite&quot;]
 *     });
 *     var q3 = new Entropy.Engine.Query({
 *         name: &quot;Ball&quot;
 *     });
 *
 * @method Query
 * @static
 * @param {Array|Object} criterions query matching criterions
 * @return {Object} query object
 */
Engine.Query = Query;

extend(Engine.prototype, EventEmitter.prototype);
extend(Engine.prototype, {
    /**
     * Creates new entity using pattern identified by &#x60;name&#x60; parameter.
     * Every additional parameter will be applied to patterns &#x60;create&#x60; method.
     * Patterns &#x60;create&#x60; method is called imediatelly after calling this method.
     *
     * @example
     *     game.engine.create(&quot;Ball&quot;, 5, 5, 5); //x, y, radius
     *
     * @method create
     * @param  {String} ...name first argument is a name of entity (entity pattern). Every additional argument will be applied to patterns &#x60;create&#x60; method.
     * @return {Engine}         engine instance
     */
    create: function (name) {
        if (is.not.unemptyString(name)) {
            debug.warn(&#x27;entity name must be a string&#x27;);
            return this;
        }

        var entityPattern = register.getEntityPattern(name);

        if (is.not.object(entityPattern)) {
            debug.warn(&#x27;entity pattern for %s does not exist&#x27;, name);
            return this;
        }

        var args = slice.call(arguments, 1);
        args.unshift(this.game);

        var entity = this._entitiesPool[name].get();
        entity = entity || new Entity(name, entityPattern, this);

        entityPattern.create.apply(entity, args);

        this._entitiesToAdd.put(entity);

        return this;
    },
    /**
     * Removes entity from engine.
     * Entity removal does not happen imediatelly, but after current update cycle.
     *
     * @example
     *     //somwhere in the system &#x27;update&#x27; method
     *     if (entity.components.hp.quantity &lt;= 0) { //entity is dead, remove
     *         game.engine.remove(entity);
     *     }
     *
     * @method remove
     * @param  {Entity} entity Entity instance
     * @return {Engine}        Engine instance
     */
    remove: function (entity) {
        if (entity == null) {
            return this;
        }

        this._entitiesToRemove.put(entity);

        return this;
    },
    getAllEntities: function () {

    },
    /**
     * Returns array of entities satisfying given {{#crossLink &quot;Query&quot;}}query{{/crossLink}} conditions.
     * Returned arrays length does not correspond with matched entities quantity.
     * To loop over entities start from 0 index, and then check if element is different than 0.
     * This method guaranties, that entities will be arranged as subsequent array slice, starting from 0 index and ending on element equal to 0.
     * The array is in this form for performance reasons.
     *
     * @example
     *     //in systems &#x27;initialize&#x27; method...
     *     this.query = new Entropy.Engine.Query([&quot;Position&quot;, &quot;Velocity&quot;]);
     *
     *     //in systems &#x27;update&#x27; method
     *     var movingEntities = this.engine.getEntities(this.query);
     *
     *     //here do something with entities in loop
     *     ...
     *
     * @method getEntities
     * @param  {Query}  query query object
     * @return {Array}  array of matched entities
     */
    getEntities: function (query) {
        if (this._queries.indexOf(query) === -1) {
            this._initializeQuery(query);
        }

        return query.entities;
    },
    /**
     * Creates new system object and adds it to the engine. System patterns &#x60;initialize&#x60; method is called (if present).
     * It can be called in two ways - with first argument being either:
     * - system name - then system has priority as defined by patterns &#x60;priority&#x60; property or 0.
     * - array with two elements - system name and its desired priority. In this case patterns &#x60;priority&#x60; property is simply skiped.
     *
     * @example
     *     game.engine.addSystem(&quot;Renderer&quot;, rendererObject);
     *
     *     //or
     *
     *     game.engine.addSystem([&quot;Renderer&quot;, 1], rendererObject);
     *
     * @method addSystem
     * @param {String|Array} ...name name of a system or array with two elements - name of a system and desired priority (see example). Additional arguments are applied to patterns &#x60;initialize&#x60; method.
     * @return {Engine} engine instance
     */
    addSystem: function (name) {
        var systemName, priority;

        if (is.array(name)) {
            if (name.length !== 2) {
                debug.warn(&#x27;To add system with priority you must provide an array with two elements - [systemName, priority] - as a first parameter.&#x27;);
                return this;
            }

            systemName = name[0];
            priority = name[1];
        } else if (is.unemptyString(name)) {
            systemName = name;
        } else {
            debug.warn(&#x27;First argument for addSystem method must be either system name or array with system name and desired priority.&#x27;);
            return this;
        }

        var pattern = register.getSystemPattern(systemName);

        if (is.not.object(pattern)) {
            debug.warn(&#x27;There is no system %s.&#x27;, name);
            return this;
        }

        if (pattern.singleton) {
            for (var i = 0, len = this._systems.length; i &lt; len; i++) {
                if (this._systems[i].name === pattern.name) {
                    debug.info(&#x27;System you want to add is a singleton and there is one already present in the engine. Returning...&#x27;);
                    return this;
                }
            }
        }

        var args = Array.prototype.slice.call(arguments, 1);

        if (priority == null) {
            if (is.number(pattern.priority)) {
                priority = pattern.priority;
            } else {
                priority = 0;
            }
        }

        var newSystem = extend(true, {}, pattern);
        newSystem.priority = priority;
        newSystem.engine = this;
        newSystem.game = this.game;

        if (is.function(newSystem.initialize)) {
            newSystem.initialize.apply(newSystem, args);
        }


        this._systemsToAdd.put(newSystem);

        return this;
    },
    removeSystem: function (system) {
        var systemObject;
        
        if (is.object(system)) {
            systemObject = system;
        } else if (is.unemptyString(system)) {
            for (var i = 0; i &lt; this._systems.length; i++) {
                systemObject = this._systems[i];
                if (systemObject.name === system) {
                    break;
                }
            }
        } else {
            debug.warn(&#x27;System to remove has to be an object or a string (system name).&#x27;);
            
            return this;
        }

        this._systemsToRemove.put(systemObject);

        return this;
    },
    enableSystem: function (system) {
        this._toggleSystem(system, false);
    },
    disableSystem: function (system) {
        this._toggleSystem(system, true);
    },
    _toggleSystem: function (system, onOff) {
        if (system == null) {
            return;
        }

        if (is.object(system)) {
            system._disabled = onOff;
        } else if (is.unemptyString(system)) {
            var systemObject;
            for (var i = 0; i &lt; this._systems.length; i++) {
                systemObject = this._systems[i];
                if (systemObject.name === system) {
                    systemObject._disabled = onOff;
                    
                    return;
                }
            }
        }
    },
    markModifiedEntity: function (entity) {
        if (entity.id === 0) {
            return;
        }

        if (array.indexOf(this._modifiedEntities, this._modifiedEntitiesLength, entity.id) !== -1) {
            return;
        }

        array.push(this._modifiedEntities, this._modifiedEntitiesLength++, entity.id);
    },
    /**
     * @method clear
     * @return {[type]} [description]
     */
    clear: function () {
        var entity;
        for (var i = 1; i &lt;= this._greatestEntityID; i++) {
            entity = this._entities[i];

            if (entity == null || entity.id === 0) {
                continue;
            }

            this._entitiesToRemove.put(entity);
        }

        for (var i = 0, len = this._systems.length; i &lt; len; i++) {
            this._systemsToRemove(this._systems[i]);
        }

        this._performClearing = true;

        return this;
    },
    update: function (event) {
        var delta = event.delta;
        var system;

        for (var i = 0, len = this._systems.length; i &lt; len; i++) {
            system = this._systems[i];

            if (system._disabled) {
                continue;
            }

            system.update(delta);
        }

        this._removeEntities();
        this._addEntities();
        this._modifyEntities();
        this._removeSystems();
        this._addSystems();
        this._fetchQueries();

        if (this._performClearing) {
            this.emit(&#x27;clear&#x27;);
            this._performClearing = false;
        }
    },
    _removeEntities: function () {
        var entityToRemove, i, len,
            index,
            indexOfEntity,
            name,
            query,
            queries = this._queries,
            systemEntities = this._entities;

        while (entityToRemove = this._entitiesToRemove.get()) {
            if (entityToRemove.id === 0) {
                continue;
            }

            for (i = 0, len = this._queries.length; i &lt; len; i++) {
                query = queries[i];

                if (!query.satisfiedBy(entityToRemove)) {
                    continue;
                }

                index = query.index;
                indexOfEntity = array.indexOf(index, query.indexLength, entityToRemove.id);

                if (indexOfEntity !== -1) {
                    query.touched = true;
                    array.removeAtIndexConst(index, query.indexLength--, indexOfEntity);
                }
            }

            if (is.function(entityToRemove.pattern.remove)) {
                entityToRemove.pattern.remove.call(entityToRemove, this.game);
            }

            systemEntities[entityToRemove.id] = 0;
            entityToRemove.id = 0;

            name = entityToRemove.name;

            this._entitiesPool[name].put(entityToRemove);
            this._entitiesCount -= 1;
        }
    },
    _addEntities: function () {
        var id, i, len,
            entityToAdd,
            query,
            queries = this._queries,
            systemEntities = this._entities;

        while (entityToAdd = this._entitiesToAdd.get()) {

            id = this._generateEntityID();

            if (id &gt; systemEntities.length) {
                array.extend(systemEntities, Math.round(1.25 * systemEntities.length));
            }

            entityToAdd.id = id;
            systemEntities[id] = entityToAdd;

            for (i = 0, len = this._queries.length; i &lt; len; i++) {
                query = queries[i];

                if (!query.satisfiedBy(entityToAdd)) {
                    continue;
                }

                query.touched = true;
                array.push(query.index, query.indexLength++, id);
            }

            this._entitiesCount += 1;
        }
    },
    _modifyEntities: function () {
         var i = 0, j, index, indexLength, len,
            query,
            queries = this._queries,
            modifiedEntity,
            systemEntities = this._entities,
            modifiedEntities = this._modifiedEntities;

        while (modifiedEntity = systemEntities[modifiedEntities[i]]) {

            modifiedEntity.applyModifications();

            for (j = 0, len = this._queries.length; j &lt; len; j++) {
                query = queries[j];

                index = query.index;
                indexLength = query.indexLength;

                var satisfied = query.satisfiedBy(modifiedEntity);
                var indexOfEntity =  array.indexOf(index, indexLength, modifiedEntity.id);

                if (satisfied &amp;&amp; indexOfEntity === -1) {
                    query.touched = true;
                    array.push(index, query.indexLength++, modifiedEntity.id);
                } else if (!satisfied &amp;&amp; indexOfEntity !== -1) {
                    query.touched = true;
                    array.removeAtIndexConst(index, query.indexLength--, indexOfEntity);
                }
            }

            i++;
        }
        array.clear(this._modifiedEntities, this._modifiedEntitiesLength);
        this._modifiedEntitiesLength = 0;
    },
    _removeSystems: function () {
        var systemToRemove;
        while (systemToRemove = this._systemsToRemove.get()) {
             var indexOfSystem = this._systems.indexOf(systemToRemove);

            if (indexOfSystem === -1) {
                //debug.warn(&#x27;Nothing to remove.&#x27;);
                continue;
            }

            if (is.function(systemToRemove.remove)) {
                systemToRemove.remove();
            }

            array.removeAtIndex(this._systems, indexOfSystem);
        }
    },
    _addSystems: function () {
        var systemToAdd, len;
        while (systemToAdd = this._systemsToAdd.get()) {
            var insertionIndex = 0;
            var priority = systemToAdd.priority;
            for (len = this._systems.length; insertionIndex &lt; len; insertionIndex++) {
                if (this._systems[insertionIndex].priority &gt; priority) {
                    break;
                }
            }

            this._systems.splice(insertionIndex, 0, systemToAdd);
        }
    },
    _fetchQueries: function () {
        var i, id, index, len,
            query,
            systemEntities = this._entities,
            queries = this._queries;

        for (i = 0, len = this._queries.length; i &lt; len; i++) {
            query = queries[i];
            if (!query.touched) {
                continue;
            }

            index = query.index;
            var entities = query.entities;
            var entitiesLength = 0;
            i = 0;
            while (id = index[i]) {
                array.push(entities, entitiesLength++, systemEntities[id]);
                i += 1;
            }

            array.push(entities, entitiesLength, 0);
            query.entitiesLength = entitiesLength;
            query.touched = false;
        }
    },
    _getNewComponent: function (name) {
        var component;
        var componentPattern = register.getComponentPattern(name);

        if (is.not.object(componentPattern)) {
            return null;
        }

        component = this._componentsPool[name].get();

        if (component == null) {
            component = {
                _pattern: componentPattern
            };
        } else if (is.function(component._pattern.reset)) {
            component._pattern.reset.call(component);
        }

        return component;
    },
    _addComponentToPool: function (component) {
        this._componentsPool[component._pattern.name].put(component);
    },
    /**
     * Returns ID for an entity. Reuses old IDs or creates new.
     *
     * @private
     * @method _generateEntityID
     * @return {Number} new ID
     */
    _generateEntityID: function () {
        var id = this._idsToReuse.get();

        if (id == null) {
            id = ++this._greatestEntityID;
        }

        return id;
    },
    /**
     * Initializes new query. Performs initial entity search.
     *
     * @private
     * @method  _initializeQuery
     * @param {Object} query query object
     */
    _initializeQuery: function (query) {
        //TODO: add check for existing query

        var entities = array.alloc(1000);
        var entitiesLength = 0;
        var index = array.alloc(1000);
        var indexLength = 0;

        var entity;
        for (var i = 1, greatestID = this._greatestEntityID; i &lt;= greatestID; i++) {
            entity = this._entities[i];
            if (entity === 0) {
                break;
            }

            if (query.satisfiedBy(entity)) {
                array.push(index, indexLength++, entity.id);
                array.push(entities, entitiesLength++, entity);
            }
        }

        extend(query, {
            entities: entities,
            entitiesLength: entitiesLength,
            index: index,
            indexLength: indexLength,
            touched: false
        });

        this._queries.push(query);
    }
});

module.exports = Engine;
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
